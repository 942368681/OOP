<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			/*
				面向对象： 
					面向对象是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物。 
				面向对象编程：
					把功能类似或者相同的代码抽离出来，归为一类，把一些描述性的特征挂在这个类的原型上的一种编程思想。
				
				js面向对象的三大特征：
					1.抽象
					2.封装
					3.继承
					(多态)
				
				属性：
					div.id
					div.index
					div.innerHTML
					div.style...
					属性前面是有主的。
					对象(obj，arr，function)下才能有属性
				
				变量:
					var arr
					前面是没有对象的（没有主的）
			
				方法：
					obj.fn = function(){
						alert(this);
					}
					方法前面有主，默认this指向主
				函数：
					function fn(){}
					函数前没有主，默认this指向window
					
				new:
					函数的运算符	
					var f = new Fn();
					new过之后，函数的返回值就变成了对象，函数里的this全部指向这个对象
					默认return这个对象。
					我们叫f为Fn的实例化对象。
					Fn叫做构造函数
					如果在构造函数中return了一个简单类型的话，那么返回值还是这个对象。
					如果构造函数中return了一个复合类型(包括函数)的话，那么写什么返回值就是什么。
					new函数之后就叫实例化，它的返回值，就是实例化对象。
					
					没有new的时候默认返回值：
						undefined
						this指向window
					new之后的返回值:
						这个对象
						this指向这个对象
					若改写返回值：
						return 简单类型 -> 这个对象
						return 复合类型 -> 复合类型
						
				原型(prototype):
					函数的一个属性，值为对象
					原型是专门处理性能问题的。
					属性放在构造函数里面
					方法挂在原型上
					
				__proto__:原型链
					对象身上没有原型但是有原型链。
					函数既有原型也有原型链。
					实例化对象的原型链 == 构造函数的原型
					原型链就是实例化对象与构造函数之间的桥梁。
					
				优先级问题：
					实例化对象上就有方法  > 构造函数原型下的方法 > Object.prototype
					对象找链 -> 构造函数的原型 -> 构造函数原型下的链 -> 构造函数的原型...
					构造函数的原型永远都是给实例化对象使用的。
					
				继承：（复用代码的一种形式）
					特点：
						1.在原有的对象基础上，略作修改，得到一个新的对象
						2.不影响原有对象的功能
					优点：	
						自己有一套自己的功能还具备父类的功能，并且不影响父类功能
					分类：
						拷贝继承
						类式继承（性能最高）
						原型继承
					拷贝继承：
						1.属性继承。
							调用父类并且改变this指向(call)
						2.方法继承。
							遍历父类的原型，把每个方法都赋值给子类。
						注意：
							不能够直接把父类的原型下的方法直接赋值给子类，因为原型的值为对象类型，而对象类型的赋值为赋址，改变子类会影响父类。
							
				包装对象：
					当简单类型去调用固定的属性或者方法的时候，那么系统内部会偷偷的把这个简单类型转成对象类型（包装对象）去调用属性或者方法，调用结束之后这个包装对象自动销毁。
					注意：
						简单类型内置对象中的属性只能读不能写。
				
				instanceof : 运算符
					左值(对象)是不是右值(构造函数)构造出来的
					
			*/
		</script>
	</body>
</html>
